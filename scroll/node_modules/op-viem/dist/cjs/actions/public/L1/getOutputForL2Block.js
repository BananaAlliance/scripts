"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOutputForL2Block = void 0;
const contracts_ts_1 = require("@eth-optimism/contracts-ts");
const actions_1 = require("viem/actions");
const action_js_1 = require("../../../errors/action.js");
const opStackContracts_js_1 = require("../../../types/opStackContracts.js");
const CONTRACT = opStackContracts_js_1.OpStackL1Contract.L2OutputOracle;
async function getOutputForL2Block(client, { l2BlockNumber, l2Chain, l2OutputOracleAddress, }) {
    if (l2Chain && l2Chain.opStackConfig.l1.chainId !== client.chain?.id) {
        throw new action_js_1.L1ChainMismatchError({ chainId: client.chain?.id, opChainL1ChainId: l2Chain.opStackConfig.l1.chainId });
    }
    if (!l2OutputOracleAddress && (!l2Chain || !l2Chain.opStackConfig.l1.contracts[CONTRACT])) {
        throw new action_js_1.L2ChainOrAddressError({ contract: CONTRACT });
    }
    const resolvedAddress = l2OutputOracleAddress ?? l2Chain.opStackConfig.l1.contracts[CONTRACT].address;
    const outputIndex = await (0, actions_1.readContract)(client, {
        address: resolvedAddress,
        abi: contracts_ts_1.l2OutputOracleABI,
        functionName: 'getL2OutputIndexAfter',
        args: [l2BlockNumber],
    });
    const proposal = await (0, actions_1.readContract)(client, {
        address: resolvedAddress,
        abi: contracts_ts_1.l2OutputOracleABI,
        functionName: 'getL2Output',
        args: [outputIndex],
    });
    return { proposal, outputIndex };
}
exports.getOutputForL2Block = getOutputForL2Block;
//# sourceMappingURL=getOutputForL2Block.js.map