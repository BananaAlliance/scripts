import { l2OutputOracleABI } from '@eth-optimism/contracts-ts';
import { OpStackL1Contract } from '../../../types/opStackContracts.js';
import { resolveL1OpStackContractAddress, } from '../../../utils/resolveL1OpStackContractAddress.js';
import { readOpStackL1 } from './readOpStackL1.js';
import { readProvenWithdrawals } from './readProvenWithdrawals.js';
const ABI = l2OutputOracleABI;
const CONTRACT = OpStackL1Contract.L2OutputOracle;
export async function getSecondsToFinalizable(client, { withdrawalHash, l2OutputOracleAddress, optimismPortalAddress, l2Chain, }) {
    const resolvedPortalAddress = resolveL1OpStackContractAddress({
        l2Chain,
        chain: client.chain,
        contract: OpStackL1Contract.OptimismPortal,
        address: optimismPortalAddress,
    });
    const provenWithdrawal = await readProvenWithdrawals(client, {
        optimismPortalAddress: resolvedPortalAddress,
        withdrawalHash,
    });
    const finalizationPeriod = await readOpStackL1(client, {
        contract: OpStackL1Contract.L2OutputOracle,
        abi: l2OutputOracleABI,
        functionName: 'FINALIZATION_PERIOD_SECONDS',
        l2Chain,
        address: l2OutputOracleAddress,
    });
    const timeSinceProven = BigInt(Date.now()) / 1000n - provenWithdrawal.timestamp;
    const finalizable = finalizationPeriod - timeSinceProven;
    // NOTE(Wilson): No negative numbers, does not make sense to have negative seconds until finalizable
    return finalizable < 0n ? 0n : finalizable;
}
//# sourceMappingURL=getSecondsToFinalizable.js.map